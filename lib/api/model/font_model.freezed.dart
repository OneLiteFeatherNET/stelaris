// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'font_model.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
  'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models',
);

FontModel _$FontModelFromJson(Map<String, dynamic> json) {
  return _FontModel.fromJson(json);
}

/// @nodoc
mixin _$FontModel {
  String? get id => throw _privateConstructorUsedError;
  String? get modelName => throw _privateConstructorUsedError;
  String? get name => throw _privateConstructorUsedError;
  String? get description => throw _privateConstructorUsedError;
  FontType get type => throw _privateConstructorUsedError;
  List<String>? get chars => throw _privateConstructorUsedError;
  int? get ascent => throw _privateConstructorUsedError;
  int? get height => throw _privateConstructorUsedError;
  List<double>? get shift => throw _privateConstructorUsedError;

  /// Serializes this FontModel to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of FontModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $FontModelCopyWith<FontModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FontModelCopyWith<$Res> {
  factory $FontModelCopyWith(FontModel value, $Res Function(FontModel) then) =
      _$FontModelCopyWithImpl<$Res, FontModel>;
  @useResult
  $Res call({
    String? id,
    String? modelName,
    String? name,
    String? description,
    FontType type,
    List<String>? chars,
    int? ascent,
    int? height,
    List<double>? shift,
  });
}

/// @nodoc
class _$FontModelCopyWithImpl<$Res, $Val extends FontModel>
    implements $FontModelCopyWith<$Res> {
  _$FontModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of FontModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? modelName = freezed,
    Object? name = freezed,
    Object? description = freezed,
    Object? type = null,
    Object? chars = freezed,
    Object? ascent = freezed,
    Object? height = freezed,
    Object? shift = freezed,
  }) {
    return _then(
      _value.copyWith(
            id:
                freezed == id
                    ? _value.id
                    : id // ignore: cast_nullable_to_non_nullable
                        as String?,
            modelName:
                freezed == modelName
                    ? _value.modelName
                    : modelName // ignore: cast_nullable_to_non_nullable
                        as String?,
            name:
                freezed == name
                    ? _value.name
                    : name // ignore: cast_nullable_to_non_nullable
                        as String?,
            description:
                freezed == description
                    ? _value.description
                    : description // ignore: cast_nullable_to_non_nullable
                        as String?,
            type:
                null == type
                    ? _value.type
                    : type // ignore: cast_nullable_to_non_nullable
                        as FontType,
            chars:
                freezed == chars
                    ? _value.chars
                    : chars // ignore: cast_nullable_to_non_nullable
                        as List<String>?,
            ascent:
                freezed == ascent
                    ? _value.ascent
                    : ascent // ignore: cast_nullable_to_non_nullable
                        as int?,
            height:
                freezed == height
                    ? _value.height
                    : height // ignore: cast_nullable_to_non_nullable
                        as int?,
            shift:
                freezed == shift
                    ? _value.shift
                    : shift // ignore: cast_nullable_to_non_nullable
                        as List<double>?,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$FontModelImplCopyWith<$Res>
    implements $FontModelCopyWith<$Res> {
  factory _$$FontModelImplCopyWith(
    _$FontModelImpl value,
    $Res Function(_$FontModelImpl) then,
  ) = __$$FontModelImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    String? id,
    String? modelName,
    String? name,
    String? description,
    FontType type,
    List<String>? chars,
    int? ascent,
    int? height,
    List<double>? shift,
  });
}

/// @nodoc
class __$$FontModelImplCopyWithImpl<$Res>
    extends _$FontModelCopyWithImpl<$Res, _$FontModelImpl>
    implements _$$FontModelImplCopyWith<$Res> {
  __$$FontModelImplCopyWithImpl(
    _$FontModelImpl _value,
    $Res Function(_$FontModelImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of FontModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? modelName = freezed,
    Object? name = freezed,
    Object? description = freezed,
    Object? type = null,
    Object? chars = freezed,
    Object? ascent = freezed,
    Object? height = freezed,
    Object? shift = freezed,
  }) {
    return _then(
      _$FontModelImpl(
        id:
            freezed == id
                ? _value.id
                : id // ignore: cast_nullable_to_non_nullable
                    as String?,
        modelName:
            freezed == modelName
                ? _value.modelName
                : modelName // ignore: cast_nullable_to_non_nullable
                    as String?,
        name:
            freezed == name
                ? _value.name
                : name // ignore: cast_nullable_to_non_nullable
                    as String?,
        description:
            freezed == description
                ? _value.description
                : description // ignore: cast_nullable_to_non_nullable
                    as String?,
        type:
            null == type
                ? _value.type
                : type // ignore: cast_nullable_to_non_nullable
                    as FontType,
        chars:
            freezed == chars
                ? _value._chars
                : chars // ignore: cast_nullable_to_non_nullable
                    as List<String>?,
        ascent:
            freezed == ascent
                ? _value.ascent
                : ascent // ignore: cast_nullable_to_non_nullable
                    as int?,
        height:
            freezed == height
                ? _value.height
                : height // ignore: cast_nullable_to_non_nullable
                    as int?,
        shift:
            freezed == shift
                ? _value._shift
                : shift // ignore: cast_nullable_to_non_nullable
                    as List<double>?,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$FontModelImpl implements _FontModel {
  const _$FontModelImpl({
    this.id,
    this.modelName,
    this.name,
    this.description,
    this.type = FontType.bitmap,
    final List<String>? chars = const [],
    this.ascent = 0,
    this.height = 0,
    final List<double>? shift = const [],
  }) : _chars = chars,
       _shift = shift;

  factory _$FontModelImpl.fromJson(Map<String, dynamic> json) =>
      _$$FontModelImplFromJson(json);

  @override
  final String? id;
  @override
  final String? modelName;
  @override
  final String? name;
  @override
  final String? description;
  @override
  @JsonKey()
  final FontType type;
  final List<String>? _chars;
  @override
  @JsonKey()
  List<String>? get chars {
    final value = _chars;
    if (value == null) return null;
    if (_chars is EqualUnmodifiableListView) return _chars;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey()
  final int? ascent;
  @override
  @JsonKey()
  final int? height;
  final List<double>? _shift;
  @override
  @JsonKey()
  List<double>? get shift {
    final value = _shift;
    if (value == null) return null;
    if (_shift is EqualUnmodifiableListView) return _shift;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'FontModel(id: $id, modelName: $modelName, name: $name, description: $description, type: $type, chars: $chars, ascent: $ascent, height: $height, shift: $shift)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FontModelImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.modelName, modelName) ||
                other.modelName == modelName) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.type, type) || other.type == type) &&
            const DeepCollectionEquality().equals(other._chars, _chars) &&
            (identical(other.ascent, ascent) || other.ascent == ascent) &&
            (identical(other.height, height) || other.height == height) &&
            const DeepCollectionEquality().equals(other._shift, _shift));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    id,
    modelName,
    name,
    description,
    type,
    const DeepCollectionEquality().hash(_chars),
    ascent,
    height,
    const DeepCollectionEquality().hash(_shift),
  );

  /// Create a copy of FontModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$FontModelImplCopyWith<_$FontModelImpl> get copyWith =>
      __$$FontModelImplCopyWithImpl<_$FontModelImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$FontModelImplToJson(this);
  }
}

abstract class _FontModel implements FontModel {
  const factory _FontModel({
    final String? id,
    final String? modelName,
    final String? name,
    final String? description,
    final FontType type,
    final List<String>? chars,
    final int? ascent,
    final int? height,
    final List<double>? shift,
  }) = _$FontModelImpl;

  factory _FontModel.fromJson(Map<String, dynamic> json) =
      _$FontModelImpl.fromJson;

  @override
  String? get id;
  @override
  String? get modelName;
  @override
  String? get name;
  @override
  String? get description;
  @override
  FontType get type;
  @override
  List<String>? get chars;
  @override
  int? get ascent;
  @override
  int? get height;
  @override
  List<double>? get shift;

  /// Create a copy of FontModel
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$FontModelImplCopyWith<_$FontModelImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
